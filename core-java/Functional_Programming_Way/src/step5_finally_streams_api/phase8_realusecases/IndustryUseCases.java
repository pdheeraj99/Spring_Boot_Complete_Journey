package step5_finally_streams_api.phase8_realusecases;

import java.util.*;
import java.util.stream.Collectors;

// Helper records for our scenarios
record Product(String name, String category, double price) {}
record Transaction(int id, String currency, double amount) {}

public class IndustryUseCases {
    public static void main(String[] args) {
        scenario1_ecommerceRevenueByCategory();
        System.out.println("\n----------------------------------------\n");
        scenario2_logFileAnalysis();
        System.out.println("\n----------------------------------------\n");
        scenario3_financialDataAggregation();
    }


    // --- Scenario 1: E-commerce Data ---
    // Problem: Given a list of product orders, find the total revenue generated by each product category.
    private static void scenario1_ecommerceRevenueByCategory() {
        System.out.println("--- Scenario 1: E-commerce Revenue by Category ---");
        List<Product> products = List.of(
                new Product("Laptop", "Electronics", 1200.00),
                new Product("Mouse", "Electronics", 25.00),
                new Product("Book: Java", "Books", 45.00),
                new Product("Keyboard", "Electronics", 75.00),
                new Product("Book: SQL", "Books", 35.00)
        );

        Map<String, Double> revenueByCategory = products.stream()
                .collect(Collectors.groupingBy(
                        Product::category, // Group by the category
                        Collectors.summingDouble(Product::price) // Downstream collector: sum the prices in each group
                ));

        System.out.println(revenueByCategory); // {Books=80.0, Electronics=1300.0}
    }

    // --- Scenario 2: Log File Analysis ---
    // Problem: Given a list of log entries, find all the unique IP addresses that generated an "ERROR" log.
    private static void scenario2_logFileAnalysis() {
        System.out.println("--- Scenario 2: Find Unique IP Addresses with ERRORs ---");
        List<String> logs = List.of(
                "123.45.67.89 - INFO - User logged in",
                "98.76.54.32 - ERROR - Database connection failed",
                "123.45.67.89 - INFO - User viewed page",
                "22.33.44.55 - WARN - Low disk space",
                "98.76.54.32 - ERROR - Null pointer exception"
        );

        Set<String> errorIps = logs.stream()
                .filter(log -> log.contains("ERROR"))    // 1. Keep only error logs
                .map(log -> log.split(" - ")[0])     // 2. Extract the IP address part
                .collect(Collectors.toSet());            // 3. Collect into a Set to get unique IPs

        System.out.println("Unique IPs with errors: " + errorIps); // [98.76.54.32]
    }

    // --- Scenario 3: Financial Data ---
    // Problem: From a list of transactions, find the highest value transaction for each currency.
    private static void scenario3_financialDataAggregation() {
        System.out.println("--- Scenario 3: Find Max Transaction per Currency ---");
        List<Transaction> transactions = List.of(
                new Transaction(1, "USD", 150.0),
                new Transaction(2, "EUR", 200.0),
                new Transaction(3, "USD", 80.0),
                new Transaction(4, "INR", 12000.0),
                new Transaction(5, "EUR", 180.0),
                new Transaction(6, "USD", 250.0)
        );

        Map<String, Optional<Transaction>> maxTransactionByCurrency = transactions.stream()
                .collect(Collectors.groupingBy(
                        Transaction::currency,
                        Collectors.maxBy(Comparator.comparing(Transaction::amount))
                ));

        System.out.println("Max transaction per currency:");
        maxTransactionByCurrency.forEach((currency, transaction) ->
                System.out.printf("  %s: %s%n", currency, transaction.orElse(null))
        );
    }
}